// Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateBaby {
  count: Int!
}

type AggregateIntervention {
  count: Int!
}

type AggregateNapEvent {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Baby {
  id: ID!
  name: String!
  napEvents(where: NapEventWhereInput, orderBy: NapEventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NapEvent!]
  parent: User!
}

type BabyConnection {
  pageInfo: PageInfo!
  edges: [BabyEdge]!
  aggregate: AggregateBaby!
}

input BabyCreateInput {
  id: ID
  name: String!
  napEvents: NapEventCreateManyWithoutBabyInput
  parent: UserCreateOneWithoutBabiesInput!
}

input BabyCreateManyWithoutParentInput {
  create: [BabyCreateWithoutParentInput!]
  connect: [BabyWhereUniqueInput!]
}

input BabyCreateOneWithoutNapEventsInput {
  create: BabyCreateWithoutNapEventsInput
  connect: BabyWhereUniqueInput
}

input BabyCreateWithoutNapEventsInput {
  id: ID
  name: String!
  parent: UserCreateOneWithoutBabiesInput!
}

input BabyCreateWithoutParentInput {
  id: ID
  name: String!
  napEvents: NapEventCreateManyWithoutBabyInput
}

type BabyEdge {
  node: Baby!
  cursor: String!
}

enum BabyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type BabyPreviousValues {
  id: ID!
  name: String!
}

input BabyScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [BabyScalarWhereInput!]
  OR: [BabyScalarWhereInput!]
  NOT: [BabyScalarWhereInput!]
}

type BabySubscriptionPayload {
  mutation: MutationType!
  node: Baby
  updatedFields: [String!]
  previousValues: BabyPreviousValues
}

input BabySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BabyWhereInput
  AND: [BabySubscriptionWhereInput!]
  OR: [BabySubscriptionWhereInput!]
  NOT: [BabySubscriptionWhereInput!]
}

input BabyUpdateInput {
  name: String
  napEvents: NapEventUpdateManyWithoutBabyInput
  parent: UserUpdateOneRequiredWithoutBabiesInput
}

input BabyUpdateManyDataInput {
  name: String
}

input BabyUpdateManyMutationInput {
  name: String
}

input BabyUpdateManyWithoutParentInput {
  create: [BabyCreateWithoutParentInput!]
  delete: [BabyWhereUniqueInput!]
  connect: [BabyWhereUniqueInput!]
  set: [BabyWhereUniqueInput!]
  disconnect: [BabyWhereUniqueInput!]
  update: [BabyUpdateWithWhereUniqueWithoutParentInput!]
  upsert: [BabyUpsertWithWhereUniqueWithoutParentInput!]
  deleteMany: [BabyScalarWhereInput!]
  updateMany: [BabyUpdateManyWithWhereNestedInput!]
}

input BabyUpdateManyWithWhereNestedInput {
  where: BabyScalarWhereInput!
  data: BabyUpdateManyDataInput!
}

input BabyUpdateOneRequiredWithoutNapEventsInput {
  create: BabyCreateWithoutNapEventsInput
  update: BabyUpdateWithoutNapEventsDataInput
  upsert: BabyUpsertWithoutNapEventsInput
  connect: BabyWhereUniqueInput
}

input BabyUpdateWithoutNapEventsDataInput {
  name: String
  parent: UserUpdateOneRequiredWithoutBabiesInput
}

input BabyUpdateWithoutParentDataInput {
  name: String
  napEvents: NapEventUpdateManyWithoutBabyInput
}

input BabyUpdateWithWhereUniqueWithoutParentInput {
  where: BabyWhereUniqueInput!
  data: BabyUpdateWithoutParentDataInput!
}

input BabyUpsertWithoutNapEventsInput {
  update: BabyUpdateWithoutNapEventsDataInput!
  create: BabyCreateWithoutNapEventsInput!
}

input BabyUpsertWithWhereUniqueWithoutParentInput {
  where: BabyWhereUniqueInput!
  update: BabyUpdateWithoutParentDataInput!
  create: BabyCreateWithoutParentInput!
}

input BabyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  napEvents_every: NapEventWhereInput
  napEvents_some: NapEventWhereInput
  napEvents_none: NapEventWhereInput
  parent: UserWhereInput
  AND: [BabyWhereInput!]
  OR: [BabyWhereInput!]
  NOT: [BabyWhereInput!]
}

input BabyWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Intervention {
  id: ID!
  timestamp: String!
  severity: Severity
  napEvent: NapEvent!
}

type InterventionConnection {
  pageInfo: PageInfo!
  edges: [InterventionEdge]!
  aggregate: AggregateIntervention!
}

input InterventionCreateInput {
  id: ID
  timestamp: String!
  severity: Severity
  napEvent: NapEventCreateOneInput!
}

type InterventionEdge {
  node: Intervention!
  cursor: String!
}

enum InterventionOrderByInput {
  id_ASC
  id_DESC
  timestamp_ASC
  timestamp_DESC
  severity_ASC
  severity_DESC
}

type InterventionPreviousValues {
  id: ID!
  timestamp: String!
  severity: Severity
}

type InterventionSubscriptionPayload {
  mutation: MutationType!
  node: Intervention
  updatedFields: [String!]
  previousValues: InterventionPreviousValues
}

input InterventionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InterventionWhereInput
  AND: [InterventionSubscriptionWhereInput!]
  OR: [InterventionSubscriptionWhereInput!]
  NOT: [InterventionSubscriptionWhereInput!]
}

input InterventionUpdateInput {
  timestamp: String
  severity: Severity
  napEvent: NapEventUpdateOneRequiredInput
}

input InterventionUpdateManyMutationInput {
  timestamp: String
  severity: Severity
}

input InterventionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  timestamp: String
  timestamp_not: String
  timestamp_in: [String!]
  timestamp_not_in: [String!]
  timestamp_lt: String
  timestamp_lte: String
  timestamp_gt: String
  timestamp_gte: String
  timestamp_contains: String
  timestamp_not_contains: String
  timestamp_starts_with: String
  timestamp_not_starts_with: String
  timestamp_ends_with: String
  timestamp_not_ends_with: String
  severity: Severity
  severity_not: Severity
  severity_in: [Severity!]
  severity_not_in: [Severity!]
  napEvent: NapEventWhereInput
  AND: [InterventionWhereInput!]
  OR: [InterventionWhereInput!]
  NOT: [InterventionWhereInput!]
}

input InterventionWhereUniqueInput {
  id: ID
  timestamp: String
}

scalar Long

type Mutation {
  createBaby(data: BabyCreateInput!): Baby!
  updateBaby(data: BabyUpdateInput!, where: BabyWhereUniqueInput!): Baby
  updateManyBabies(data: BabyUpdateManyMutationInput!, where: BabyWhereInput): BatchPayload!
  upsertBaby(where: BabyWhereUniqueInput!, create: BabyCreateInput!, update: BabyUpdateInput!): Baby!
  deleteBaby(where: BabyWhereUniqueInput!): Baby
  deleteManyBabies(where: BabyWhereInput): BatchPayload!
  createIntervention(data: InterventionCreateInput!): Intervention!
  updateIntervention(data: InterventionUpdateInput!, where: InterventionWhereUniqueInput!): Intervention
  updateManyInterventions(data: InterventionUpdateManyMutationInput!, where: InterventionWhereInput): BatchPayload!
  upsertIntervention(where: InterventionWhereUniqueInput!, create: InterventionCreateInput!, update: InterventionUpdateInput!): Intervention!
  deleteIntervention(where: InterventionWhereUniqueInput!): Intervention
  deleteManyInterventions(where: InterventionWhereInput): BatchPayload!
  createNapEvent(data: NapEventCreateInput!): NapEvent!
  updateNapEvent(data: NapEventUpdateInput!, where: NapEventWhereUniqueInput!): NapEvent
  updateManyNapEvents(data: NapEventUpdateManyMutationInput!, where: NapEventWhereInput): BatchPayload!
  upsertNapEvent(where: NapEventWhereUniqueInput!, create: NapEventCreateInput!, update: NapEventUpdateInput!): NapEvent!
  deleteNapEvent(where: NapEventWhereUniqueInput!): NapEvent
  deleteManyNapEvents(where: NapEventWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type NapEvent {
  id: ID!
  start: String!
  end: String
  status: Status!
  baby: Baby!
}

type NapEventConnection {
  pageInfo: PageInfo!
  edges: [NapEventEdge]!
  aggregate: AggregateNapEvent!
}

input NapEventCreateInput {
  id: ID
  start: String!
  end: String
  status: Status!
  baby: BabyCreateOneWithoutNapEventsInput!
}

input NapEventCreateManyWithoutBabyInput {
  create: [NapEventCreateWithoutBabyInput!]
  connect: [NapEventWhereUniqueInput!]
}

input NapEventCreateOneInput {
  create: NapEventCreateInput
  connect: NapEventWhereUniqueInput
}

input NapEventCreateWithoutBabyInput {
  id: ID
  start: String!
  end: String
  status: Status!
}

type NapEventEdge {
  node: NapEvent!
  cursor: String!
}

enum NapEventOrderByInput {
  id_ASC
  id_DESC
  start_ASC
  start_DESC
  end_ASC
  end_DESC
  status_ASC
  status_DESC
}

type NapEventPreviousValues {
  id: ID!
  start: String!
  end: String
  status: Status!
}

input NapEventScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  start: String
  start_not: String
  start_in: [String!]
  start_not_in: [String!]
  start_lt: String
  start_lte: String
  start_gt: String
  start_gte: String
  start_contains: String
  start_not_contains: String
  start_starts_with: String
  start_not_starts_with: String
  start_ends_with: String
  start_not_ends_with: String
  end: String
  end_not: String
  end_in: [String!]
  end_not_in: [String!]
  end_lt: String
  end_lte: String
  end_gt: String
  end_gte: String
  end_contains: String
  end_not_contains: String
  end_starts_with: String
  end_not_starts_with: String
  end_ends_with: String
  end_not_ends_with: String
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  AND: [NapEventScalarWhereInput!]
  OR: [NapEventScalarWhereInput!]
  NOT: [NapEventScalarWhereInput!]
}

type NapEventSubscriptionPayload {
  mutation: MutationType!
  node: NapEvent
  updatedFields: [String!]
  previousValues: NapEventPreviousValues
}

input NapEventSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NapEventWhereInput
  AND: [NapEventSubscriptionWhereInput!]
  OR: [NapEventSubscriptionWhereInput!]
  NOT: [NapEventSubscriptionWhereInput!]
}

input NapEventUpdateDataInput {
  start: String
  end: String
  status: Status
  baby: BabyUpdateOneRequiredWithoutNapEventsInput
}

input NapEventUpdateInput {
  start: String
  end: String
  status: Status
  baby: BabyUpdateOneRequiredWithoutNapEventsInput
}

input NapEventUpdateManyDataInput {
  start: String
  end: String
  status: Status
}

input NapEventUpdateManyMutationInput {
  start: String
  end: String
  status: Status
}

input NapEventUpdateManyWithoutBabyInput {
  create: [NapEventCreateWithoutBabyInput!]
  delete: [NapEventWhereUniqueInput!]
  connect: [NapEventWhereUniqueInput!]
  set: [NapEventWhereUniqueInput!]
  disconnect: [NapEventWhereUniqueInput!]
  update: [NapEventUpdateWithWhereUniqueWithoutBabyInput!]
  upsert: [NapEventUpsertWithWhereUniqueWithoutBabyInput!]
  deleteMany: [NapEventScalarWhereInput!]
  updateMany: [NapEventUpdateManyWithWhereNestedInput!]
}

input NapEventUpdateManyWithWhereNestedInput {
  where: NapEventScalarWhereInput!
  data: NapEventUpdateManyDataInput!
}

input NapEventUpdateOneRequiredInput {
  create: NapEventCreateInput
  update: NapEventUpdateDataInput
  upsert: NapEventUpsertNestedInput
  connect: NapEventWhereUniqueInput
}

input NapEventUpdateWithoutBabyDataInput {
  start: String
  end: String
  status: Status
}

input NapEventUpdateWithWhereUniqueWithoutBabyInput {
  where: NapEventWhereUniqueInput!
  data: NapEventUpdateWithoutBabyDataInput!
}

input NapEventUpsertNestedInput {
  update: NapEventUpdateDataInput!
  create: NapEventCreateInput!
}

input NapEventUpsertWithWhereUniqueWithoutBabyInput {
  where: NapEventWhereUniqueInput!
  update: NapEventUpdateWithoutBabyDataInput!
  create: NapEventCreateWithoutBabyInput!
}

input NapEventWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  start: String
  start_not: String
  start_in: [String!]
  start_not_in: [String!]
  start_lt: String
  start_lte: String
  start_gt: String
  start_gte: String
  start_contains: String
  start_not_contains: String
  start_starts_with: String
  start_not_starts_with: String
  start_ends_with: String
  start_not_ends_with: String
  end: String
  end_not: String
  end_in: [String!]
  end_not_in: [String!]
  end_lt: String
  end_lte: String
  end_gt: String
  end_gte: String
  end_contains: String
  end_not_contains: String
  end_starts_with: String
  end_not_starts_with: String
  end_ends_with: String
  end_not_ends_with: String
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  baby: BabyWhereInput
  AND: [NapEventWhereInput!]
  OR: [NapEventWhereInput!]
  NOT: [NapEventWhereInput!]
}

input NapEventWhereUniqueInput {
  id: ID
  start: String
  end: String
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  baby(where: BabyWhereUniqueInput!): Baby
  babies(where: BabyWhereInput, orderBy: BabyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Baby]!
  babiesConnection(where: BabyWhereInput, orderBy: BabyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BabyConnection!
  intervention(where: InterventionWhereUniqueInput!): Intervention
  interventions(where: InterventionWhereInput, orderBy: InterventionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Intervention]!
  interventionsConnection(where: InterventionWhereInput, orderBy: InterventionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InterventionConnection!
  napEvent(where: NapEventWhereUniqueInput!): NapEvent
  napEvents(where: NapEventWhereInput, orderBy: NapEventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NapEvent]!
  napEventsConnection(where: NapEventWhereInput, orderBy: NapEventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NapEventConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum Severity {
  LOW
  MEDIUM
  HEAVY
}

enum Status {
  COMPLETE
  ONGOING
  INCOMPLETE
}

type Subscription {
  baby(where: BabySubscriptionWhereInput): BabySubscriptionPayload
  intervention(where: InterventionSubscriptionWhereInput): InterventionSubscriptionPayload
  napEvent(where: NapEventSubscriptionWhereInput): NapEventSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  password: String!
  name: String!
  babies(where: BabyWhereInput, orderBy: BabyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Baby!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
  name: String!
  babies: BabyCreateManyWithoutParentInput
}

input UserCreateOneWithoutBabiesInput {
  create: UserCreateWithoutBabiesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutBabiesInput {
  id: ID
  email: String!
  password: String!
  name: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  name: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  babies: BabyUpdateManyWithoutParentInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  name: String
}

input UserUpdateOneRequiredWithoutBabiesInput {
  create: UserCreateWithoutBabiesInput
  update: UserUpdateWithoutBabiesDataInput
  upsert: UserUpsertWithoutBabiesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutBabiesDataInput {
  email: String
  password: String
  name: String
}

input UserUpsertWithoutBabiesInput {
  update: UserUpdateWithoutBabiesDataInput!
  create: UserCreateWithoutBabiesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  babies_every: BabyWhereInput
  babies_some: BabyWhereInput
  babies_none: BabyWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`